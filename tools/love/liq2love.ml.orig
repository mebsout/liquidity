open LiquidTypes
open Love_ast
open Love_type
open Love_ast_utils
open Compil_utils

module SMap = Love_collections.StringMap
module SIMap = Love_collections.StringIdentMap

(* Unknown type returns the type name and a function allowing to build
   the type if given back *)

type subenv = {
  typedefs : (string * typedef) list; (* Ordered (reversed) typedefs for the current contract *)
}

type env = subenv Love_tenv.t

exception UnknownType of (string * (Love_type.t -> Love_type.t) * env)

let env_of_subcontract ?(storage_type=TUnit) is_module env =
  let subenv = {typedefs = []}
  in Love_tenv.new_subcontract_env ~storage_type is_module subenv env

let add_typedef_to_contract tdef env =
  Love_log.debug "[add_typedef_to_contract] Adding %a to the environment@." Love_type.pp_typdef tdef;
  let name = match tdef with
      SumType {sname = name; _}
    | RecordType {rname = name; _} -> name.tname in
  let new_env = Love_tenv.set_data ({typedefs = (name,tdef) :: (Love_tenv.get_data env).typedefs}) env
  in Love_tenv.add_typedef tdef new_env

let debug (msg: ('a, Format.formatter, unit) format) = Format.printf msg

let empty_env ?(storage_type = TUnit) is_module () =
  let subenv = {typedefs = []} in
  Love_tenv.empty ~storage_type is_module subenv ()

let find_type tname env =
  let search n env =
    let typedefs = (Love_tenv.get_data env).typedefs in
    debug "[find_type] Typedefs = %a@."
    (Format.pp_print_list
       (fun fmt (n,td) -> Format.fprintf fmt "type %s = %a\n" n Love_type.pp_typdef td)) typedefs;
    List.find_opt
      (fun (name, _tdef) ->
         let res =  String.equal name n in
         debug "[find_type] %s = %s ? %b@." name n res; res
      ) typedefs
  in
  Love_tenv.find_env (string_to_ident tname) env search
  (*
  let rec search_envs env l =
    match Love_ident.split l with
      tname, None ->
      List.find_opt (fun (name, _tdef) -> String.equal name tname) (Love_tenv.get_data env).typedefs
    | cname, Some id ->
      match Love_tenv.find_contract (Love_ident.create_id cname) env with
        None -> debug "[find_type] Contract %s not found in environment %a."
                  cname Love_tenv.pp_env env;
        failwith ("Unknown contract "^ cname)
      | Some (Structure e) -> search_envs e id
      | Some (Signature n) -> (
          match Love_tenv.find_signature n env with
            None ->
            debug "[find_type] Signature %s not found in environment %a." cname Love_tenv.pp_env env;
            failwith ("Unknown signature "^ cname)
          | Some e -> search_envs e id
        )
  in search_envs env tident *)

let get_opt o = match o with None -> assert false | Some o -> o

let rec apply_cont cont name love_ty =
  try cont love_ty with
    UnknownType (n, cont,_) when String.equal n name ->
    apply_cont cont name love_ty
  | UnknownType (n, cont,_) when String.equal n "Partial" ->
    cont (TVar (Love_type.fresh_typevar ()))
(* Transforms a tv Ref.t into a TVar.t.
   If a tv aliases another tv, the same Tvar will be generated.  *)

let rec fvars =
  function
  | Tunit
  | Tbool
  | Tint
  | Tnat
  | Ttez
  | Tstring
  | Tbytes
  | Ttimestamp
  | Tkey
  | Tkey_hash
  | Tsignature
  | Toperation
  | Taddress -> StringSet.empty

  | Ttuple l ->
    List.fold_left (fun acc elt -> StringSet.union acc @@ fvars elt) StringSet.empty l

  | Toption t
  | Tlist t
  | Tset t -> fvars t

  | Tmap (t1, t2)
  | Tbigmap (t1, t2)
  | Tor (t1, t2)
  | Tlambda (t1, t2, _) -> StringSet.union (fvars t1) (fvars t2)
  | Tcontract _ -> StringSet.empty

  | Trecord (_, l)
  | Tsum  (_, l) ->
    List.fold_left (fun acc (_,t) -> StringSet.union acc @@ fvars t)
      StringSet.empty
      l
  | Tclosure ((t1, t2), t3, _) ->
    StringSet.union (StringSet.union (fvars t1) (fvars t2)) @@ fvars t3
  | Tfail -> StringSet.empty

  | Tvar v -> StringSet.singleton !(v.contents).id
  | Tpartial p -> (
      match p with
        Peqn _ | Pcont _ | Ppar -> failwith "TODO : partial not supported"
      | Ptup l ->
        List.fold_left
          (fun acc (_,elt) -> StringSet.union acc @@ fvars elt)
          StringSet.empty
          l
      | Pmap (t1, t2) -> StringSet.union (fvars t1) (fvars t2)
    )

let rec liqtype_to_lovetypedef (env : env) t : typedef option =
  let params = StringSet.elements @@ fvars t in (* what if the type has no parameter ? *)
  match t with
  | Tsum (sname, l) ->
    let sparams =
      List.map
        (fun t -> (Love_type.fresh_typevar ~name:t ()))
        params
    in
    let love_name = Love_type.fresh_typename sname in
    let love_ty =
      TUser (love_name,
            List.map (fun p -> TVar p) sparams)
    in
    let scons =
      List.map
        (fun (name, cons) ->
           let t =
             try (liqtype_to_lovetype env) cons
             with UnknownType (n, cont, _) when String.equal n sname ->
               apply_cont cont sname love_ty
           in
           debug "[liqtype_to_lovedef] %s of type %a@." name Love_type.pretty t;
           name, [t]
        )
        l
    in Some (Love_ast_utils.mk_sumtype sparams sname scons)
  | Trecord (rname, l) ->
    let rparams =
      List.map
        (fun t -> (Love_type.fresh_typevar ~name:t ()))
        params
    in
    let love_name = Love_type.fresh_typename rname in
    let love_ty =
      TUser (love_name,
            List.map (fun p -> TVar p) rparams)
    in
    let rcons =
      List.map
        (fun (name, cons) ->
           let t =
             try  (liqtype_to_lovetype env) cons
             with UnknownType (n, cont, _) when String.equal n rname ->
               apply_cont cont rname love_ty
           in name, t
        )
        l
    in Some (Love_ast_utils.mk_rectype rparams rname rcons)

  | _ -> None

and tvref_to_tvar (env : env) tvref : Type.t =
  debug "[tvref_to_tvar] Creating a TVar@.";
  let tv = !(tvref.Ref.contents) in
  match tv.tyo with
    Some t -> (
    try liqtype_to_lovetype env t
    with
      UnknownType (n, f, _) when String.equal n "Partial" ->
      debug "[tvref_to_tvar] Partial TVar@.";
      f (TVar (Love_type.fresh_typevar ()))
  )
  | None -> ( (* Type has not been found for tvref. Checking on aliases *)
    let aliases = !(tvref.Ref.aliases) in
    let rec check_aliases_info =
      function
        [] -> None
      | {Ref.contents; _}   :: tl -> (
          match (!contents).tyo with
            None -> check_aliases_info tl
          | Some t -> Some (liqtype_to_lovetype env t)
      )
    in
    match check_aliases_info aliases with
      Some t -> t (* One of the aliases had the type *)
    | None -> ( (* No aliases, creating a TVar *)
        let sorted_aliases = (* Maybe not necesary to sort, ask Alain *)
          List.fast_sort
            (fun (t1 : LiquidTypes.tv LiquidTypes.Ref.t) t2 ->
               String.compare !(t1.contents).id !(t2.contents).id
            )
            aliases
        in
        let new_name =
          List.fold_left
            (fun acc (v: LiquidTypes.tv LiquidTypes.Ref.t)
              -> acc ^ (!(v.contents).id)
            )
            "_liq_" (* Starting by '_liq_' to avoid redefinition. *)
            sorted_aliases
        in
        debug "[tvref_to_tvar] TVar %s@." new_name;
        TVar {tv_name = new_name; tv_traits = [TComparable; TPure]}
      )
  )

and get_tvar_from_tlist env tlist : Type.t list =
  let rec get_tvars (acc: Type.t SMap.t) =
    function
    | [] -> acc
    | Tvar tv :: tl -> (
        let new_t = tvref_to_tvar env tv in
        match new_t with
        | TVar {tv_name; _} -> get_tvars (SMap.add tv_name new_t acc) tl
        | _ -> get_tvars acc tl
      )
    | _ :: tl -> get_tvars acc tl
  in
  SMap.fold
    (fun _ bnd acc -> bnd :: acc)
    (get_tvars SMap.empty tlist)
    []

and liqcontract_sig_to_lovetype
    ?storage_type
    (env : env)
    {sig_name; entries_sig} : structure_type =
  debug "[liqcontract_sig_to_lovetype] Creating type from liquidity contract@.";
  match sig_name with
    Some name -> (
      debug "[liqcontract_sig_to_lovetype] Module is named %s@." name;
      match Love_tenv.find_contract (Love_ident.create_id name) env with
        Some _ -> (* The signature has already been registered *)
        debug "[liqcontract_sig_to_lovetype] Already registered@.";
        Named (Love_ident.create_id name)
      | None ->
        debug "[liqcontract_sig_to_lovetype] Not registered, treating as anonymous@.";
        liqcontract_sig_to_lovetype ?storage_type env {sig_name = None; entries_sig}
    )
  | None ->
    debug "[liqcontract_sig_to_lovetype] Anonymous contract@.";
    let entry_sig_to_love_content env entry =
      let name = entry.entry_name in
      let typ, tdef =
        match entry.parameter with
          Tsum (name, _) as t -> (
            try liqtype_to_lovetype env t, None with
              UnknownType (n, _, _) when String.equal name n ->
              debug "[liqcontract_sig_to_lovetype] Sum type %s defined in signature@." name;
              (* entry.parameter has not been defined yet. *)
              let tdef = liqtype_to_lovetypedef env t in
              match tdef with
                Some (Type.SumType {sparams; _} as td) ->
                TUser (Type.fresh_typename name, List.map (fun v -> TVar v) sparams), Some (name, td)
              | _ -> assert false
        )
        | Trecord (name, _) as t -> (
            try liqtype_to_lovetype env t, None with
              UnknownType (n, _, _) when String.equal name n ->
              debug "[liqcontract_sig_to_lovetype] Record type %s defined in signature@." name;
              (* entry.parameter has not been defined yet. *)
              let tdef = liqtype_to_lovetypedef env t in
              match tdef with
                Some (Type.RecordType {rparams; _} as td) ->
                TUser (Type.fresh_typename name, List.map (fun v -> TVar v) rparams), Some (name, td)
              | _ -> assert false)
        | t -> liqtype_to_lovetype env t, None
      in
      debug "[liqcontract_sig_to_lovetype] Entry %s : %a@." name Type.pretty typ;
      name, (typ, TUnit), tdef
    in
    let entries, types, _env =
      List.fold_left
        (fun (acc_entry,acc_tdef, env) entry ->
           let name, (t1, t2), tdef = entry_sig_to_love_content env entry
           in
           let acc_tdef, env =
             match tdef with
               None -> acc_tdef, env
             | Some (n,t) ->
               StringMap.add n t acc_tdef,
               add_typedef_to_contract t env
           in
           StringMap.add name (Forbid, t1, t2) acc_entry,acc_tdef, env
        )
        (StringMap.empty, StringMap.empty, env)
        entries_sig
    in
    let storage_type =
      match storage_type with
        Some _ -> storage_type
      | None -> (
          match entries_sig with
            [] -> None
          | ({storage_name;_}) :: _ ->
            let name = "##"^storage_name in
            Some (TVar (Love_type.fresh_typevar ~name ()))
        )
    in
    Anonymous {
      storage_type;
      entries;
      values = StringMap.empty;
      structures = StringMap.empty;
      signatures = StringMap.empty;
      types;
      is_module = StringMap.is_empty entries
    }

and liqtype_to_lovetype (env : env) tv =
  let ltl = liqtype_to_lovetype env in
  let action res t =
    let t =
      try ltl t
      with
        UnknownType (name, f, env) ->
        debug "[liqtype_to_lovetype] Unknown type %s, sending task to sender@." name;
        raise (UnknownType (name, (fun t -> res @@ f t), env))
    in res t
  in
  match tv with
    Tunit -> debug "[liqtype_to_lovetype] Unit@."; TUnit
  | Tbool -> debug "[liqtype_to_lovetype] Bool@."; TBool
  | Tint  -> debug "[liqtype_to_lovetype] Int@."; TInt
  | Tnat  -> debug "[liqtype_to_lovetype] Nat = Int@."; TInt
  | Ttez  -> debug "[liqtype_to_lovetype] Tez = Dun@."; TDun
  | Tstring -> debug "[liqtype_to_lovetype] String@."; TString
  | Tbytes -> debug "[liqtype_to_lovetype] Bytes@."; TBytes
  | Ttimestamp -> debug "[liqtype_to_lovetype] Timestamp@."; TTimestamp
  | Tkey -> debug "[liqtype_to_lovetype] TKey@."; TKey
  | Tkey_hash ->  debug "[liqtype_to_lovetype] TKeyHash@."; TKeyHash
  | Tsignature ->  debug "[liqtype_to_lovetype] Signature@."; TSignature
  | Toperation ->  debug "[liqtype_to_lovetype] Operation@."; TOperation
  | Taddress ->  debug "[liqtype_to_lovetype] Address@."; TAddress

  | Ttuple l ->
    debug "[liqtype_to_lovetype] Tuple of size %i@." (List.length l);
    let rec loop acc =
      debug "[liqtype_to_lovetype] Next tuple element@.";
      function
        [] -> TTuple (List.rev acc)
      | hd :: tl ->
        let res t = loop (t :: acc) tl
        in action res hd
    in
    let res = loop [] l in
    debug "[liqtype_to_lovetype] Output : %a@." Love_type.pretty res; res
  | Toption t ->
    debug "[liqtype_to_lovetype] Option@.";
    let res t = TOption t in
    action res t

  | Tlist t ->
    debug "[liqtype_to_lovetype] List@.";
    let res t = TList t in
    action res t

  | Tset t ->
    debug "[liqtype_to_lovetype] Set@.";
    let res t = TSet t in
    action res t

  | Tmap (t1, t2) ->
    debug "[liqtype_to_lovetype] Map@.";
    let res t1 t2 = TMap (t1, t2) in
    let t2 t1 =
      try res t1 (ltl t2) with
        UnknownType (name, f, e) ->
        raise (UnknownType (name, (fun t2 -> res t1 @@ f t2), e))
    in
    let t1 =
      try ltl t1
      with
        UnknownType (name, f, e) ->
        raise (UnknownType (name, (fun t -> let t1 = f t in t2 t1), e))
    in t2 t1

  | Tbigmap (t1, t2) ->
    debug "[liqtype_to_lovetype] Bigmap@.";
    let res t1 t2 = TBigMap (t1, t2) in
    let t2 t1 =
      try res t1 (ltl t2) with
        UnknownType (name, f, e) ->
        raise (UnknownType (name, (fun t2 -> res t1 @@ f t2), e))
    in
    let t1 =
      try ltl t1
      with
        UnknownType (name, f, e) ->
        raise (UnknownType (name, (fun t -> let t1 = f t in t2 t1), e))
    in t2 t1
  | Tcontract c ->
    debug "[liqtype_to_lovetype] Contract@.";
    TContractInstance (liqcontract_sig_to_lovetype env c)
  | Tor (t1,t2) -> (
      let t1 = ltl t1 and t2 = ltl t2 in
      let sumtyp = TUser (Compil_utils.Tor.tor_typename, [t1;t2]) in
      match t1, t2 with
        TVar v1, TVar v2 ->
        TForall (v1, TForall (v2, sumtyp))
      | TVar v, _
      | _, TVar v -> TForall (v, sumtyp)
      | _,_ -> sumtyp
    )
  | Tlambda (t1, t2, _) ->
    debug "[liqtype_to_lovetype] Lambda@.";
    let t2 t1 =
      try debug "[liqtype_to_lovetype] t1 = %a, calculating t2@." Love_type.pretty t1;
        t1 @=> (ltl t2) with
        UnknownType (name, f, e) ->
        raise (UnknownType (name, (fun t2 -> t1 @=> f t2), e))
    in
    let t1 =
      try ltl t1
      with
        UnknownType (name, f, e) ->
        raise (UnknownType (name, (fun t -> let t1 = f t in t2 t1), e))
    in t2 t1
  | Trecord (name, fields) -> (
      debug "[liqtype_to_lovetype] Record@.";
      match find_type name env with
        None -> raise (UnknownType (name, (fun t -> t), env))
      | Some (_, RecordType {rname; rparams;rfields}) ->
        let params =
          let rec instanciate_params params_map poly_fields fields =
            match poly_fields with
              (name, TVar t) :: tl_p ->
              let _, t' = List.find (fun (n, _) -> String.equal name n) fields in
              instanciate_params (TypeVarMap.add t t' params_map) tl_p fields
            | _ :: tl_p ->
              instanciate_params params_map tl_p fields
            | [] -> params_map
          in
          instanciate_params TypeVarMap.empty rfields fields
        in
        let rparams_replaced =
          List.map (fun param -> ltl @@ TypeVarMap.find param params) rparams
        in
        let t = TUser (rname, rparams_replaced)
        in
        debug "[liqtype_to_lovetype] Record type = %a@." Type.pretty t;
        t
      | Some _ -> assert false
    )
  | Tsum (name, cons) -> (
      debug "[liqtype_to_lovetype] Sum@.";
      match find_type name env with
        None -> raise (UnknownType (name, (fun t -> t), env))
      | Some (_, SumType {sname; sparams; scons}) ->
        let params =
          let rec instanciate_params params_map poly_cons cons =
            match poly_cons with
              (name, l) :: tl_p ->
              debug "[liqtype_to_lovetype] Constructor %s@." name;
              let l =
                match l with
                  [TTuple l] ->
                  debug "[liqtype_to_lovetype] %s of %a, %i arguments @."
                    name
                    Love_type.pretty (TTuple l)
                    (List.length l);
                  l
                | [TUnit] -> []
                | [t] -> [t]
                | _ -> assert false in
              debug "[liqtype_to_lovetype] Arguments : %i@." (List.length l) ;
              let l' =
                match
                  List.find
                    (fun (n, _) -> String.equal (Love_ident.get_final (string_to_ident n)) name)
                    cons
                with
                  _, Ttuple l -> l
                | _, Tunit -> []
                | _, ty -> [ty]
                | exception Not_found ->
                  debug "[liqtype_to_lovetype] Constructors list = %a@."
                    (Format.pp_print_list (fun fmt (s, _) -> Format.fprintf fmt "%s," s)) cons;
                  raise Not_found
              in
              let new_map =
                try
                  List.fold_left2
                    (fun acc polyt t ->
                       match polyt with
                         TVar tv ->
                         TypeVarMap.add tv t acc
                       | _ -> acc
                    )
                    params_map
                    l
                    l'
                with Invalid_argument _ ->
                  debug "[liqtype_to_lovetype] Size l = %i; size l' = %i@."
                    (List.length l)
                    (List.length l');
                  failwith "List sizes are incompatible"
              in
              instanciate_params new_map tl_p cons
            | [] -> params_map
          in
          instanciate_params TypeVarMap.empty scons cons
        in
        let sparams_replaced =
          List.map (fun param -> ltl @@ TypeVarMap.find param params) sparams
        in
        let t = TUser (sname, sparams_replaced) in
        debug "[liqtype_to_lovetype] Sum type = %a" Type.pretty t;
        t
      | Some _ -> assert false
    )
  | Tvar v ->
    debug "[liqtype_to_lovetype] Tvar@.";
    tvref_to_tvar env v
  | Tfail ->
    debug "[liqtype_to_lovetype] Fail@.";
    raise (UnknownType ("Fail", (fun t -> t), env))
  | Tpartial p -> (
      debug "[liqtype_to_lovetype] Partial %s@." (LiquidPrinter.Liquid.string_of_type tv);
      match p with
        Peqn _ | Pcont _ | Ppar | Pmap _ -> raise (UnknownType ("Partial", (fun t -> t), env))
      | Ptup l ->
        debug "[liqtype_to_lovetype] Partial tuple@.";
        let l = List.fast_sort (fun (i1, _) (i2, _) -> i1 - i2) l in
        let rec create_tuple_content acc cpt l =
        debug "[liqtype_to_lovetype] Tuple index %i@." cpt;
          match l with
            (index, typ) :: tl ->
            if cpt = index
            then (
              debug "[liqtype_to_lovetype] Defined type@.";
              create_tuple_content (typ :: acc) (cpt + 1) tl
            )
            else (
              debug "[liqtype_to_lovetype] Undefined type@.";
              let tvar = {id = Format.asprintf "'a.%i" cpt; tyo = None} in
              create_tuple_content
                (Tvar (LiquidTypes.Ref.create tvar) :: acc)
                (cpt + 1)
                tl
            )
          | [] -> List.rev acc
        in
        let tuple_content = create_tuple_content [] 0 l in
        debug "[liqtype_to_lovetype] Tuple has size %i@." (List.length tuple_content);
        ltl (Ttuple tuple_content)
    )
  | Tclosure ((t1,t2), t3, _) ->
    debug "[liqtype_to_lovetype] Closure@.";
    let t1 =
      let res = ltl t1 in
      debug "[liqtype_to_lovetype] t1=%a@." Love_type.pretty res; res
    in
    let _t2 =
      let res = ltl t2 in
      debug "[liqtype_to_lovetype] t2=%a@." Love_type.pretty res; res
    in
    let t3 =
      let res = ltl t3 in
      debug "[liqtype_to_lovetype] t3=%a@." Love_type.pretty res; res
    in
    TArrow (t1, t3)

let rec remove_forall t =
  match t with
    TForall (_, t) -> remove_forall t
  | _ -> t

let liqprim_to_loveprim env (p : primitive) (args : Love_type.t list)
  : Love_primitive.t * Love_type.t list =
  debug "[liqprim_to_loveprim] Primitive tranpilation@.";
  let eq_type l =
    debug "[liqprim_to_loveprim] Types of arguments are equal@.";
    match l with
      [a1; a2] ->  (
        debug "[liqprim_to_loveprim] %a = %a@." Type.pretty a1 Type.pretty a2;
        match a1, a2 with
          TVar _, t| t, TVar _ | t, _ -> [t;t]
      )
    | [a] -> [a]
    | [] ->  []
    | _ -> failwith "Too many arguments"
  in
  match p with
  (* resolved in LiquidCheck *)
  | (Prim_coll_find
  | Prim_coll_update
  | Prim_coll_mem
  | Prim_coll_size) -> failwith "After LiquidCheck, this primitive is forbidden"

  (* extended primitives *)
  | Prim_extension (s1, _b, _l, _i1, _i2, _s2) ->
    let error = Format.asprintf "Primitive %s unknown" s1 in
    debug "[liqprim_to_loveprim] %s@." error;
    failwith error
  (* generated in LiquidCheck *)
  | Prim_unused _so -> assert false (* todo *)

  (* primitives *)
  | (Prim_tuple_get | Prim_tuple_set| Prim_tuple) -> assert false (* treated elsewhere *)

  | Prim_self            -> assert false (* done elsewhere *)
  | Prim_balance         -> PCBalance, args
  | Prim_now             -> PCTime, args
  | Prim_amount          -> PCAmount, args
  | Prim_gas             -> PCGas, args
  | Prim_Left            -> assert false (* done elsewhere *)
  | Prim_Right           -> assert false (* done elsewhere *)
  | Prim_source          -> PCSource, args
  | Prim_sender          -> PCSender, args
  | Prim_eq  -> debug "[liqprim_to_loveprim] Eq@."; PEq, eq_type args
  | Prim_neq -> debug "[liqprim_to_loveprim] Ne@."; PNe, eq_type args
  | Prim_lt  -> debug "[liqprim_to_loveprim] Lt@."; PLt, eq_type args
  | Prim_le  -> debug "[liqprim_to_loveprim] Le@."; PLe, eq_type args
  | Prim_gt  -> debug "[liqprim_to_loveprim] Gt@."; PGt, eq_type args
  | Prim_ge  -> debug "[liqprim_to_loveprim] Ge@."; PGe, eq_type args
  | Prim_compare -> debug "[liqprim_to_loveprim] Compare"; PCompare, eq_type args
  | Prim_add -> (
    debug "[liqprim_to_loveprim] Addition@.";
    match args with
    | [t1; t2] -> (
        match t1, t2 with
        | TInt, TInt                  -> Love_primitive.PIAdd, args
        | TDun, (TDun | TVar _)       -> PDAdd, [TDun; TDun]
        | TTimestamp, (TInt | TVar _) -> PTIAdd, [TTimestamp; TInt]
        | (TInt | TVar _), TTimestamp -> PITAdd, [TInt; TTimestamp]
        | _,_ ->
          debug "[liqprim_to_loveprim] Forbidden addition on %a and %a."
            Love_type.pretty t1 Love_type.pretty t2;
          failwith "Addition on bad types"
      )
    | [arg] -> (
        match arg with
          TDun -> PDAdd, args
        | TTimestamp -> PTIAdd, args
        | _ ->
          debug
            "[liqprim_to_loveprim] Type %a is insufficient to guess the correct addition primitive."
            Love_type.pretty arg;
          failwith "Cannot infer correct addition primitive"
      )
    | [] -> failwith "Type of addition cannot be inferred from no arguments."
    | _ ->  failwith "Too many arguments"
  )
  | Prim_sub -> (
    debug "[liqprim_to_loveprim] Substraction@.";
    match args with
    | [t1; t2] -> (
        match t1, t2 with
        | TInt, TInt                  -> Love_primitive.PISub, args
        | TDun, (TDun | TVar _)       -> PDSub, [TDun; TDun]
        | TTimestamp, TInt            -> PTISub, [TTimestamp; TInt]
        | (TTimestamp | TVar _), TTimestamp -> PTSub, [TTimestamp; TTimestamp]
        | _,_ ->
          debug "[liqprim_to_loveprim] Forbidden substraction on %a and %a."
            Love_type.pretty t1 Love_type.pretty t2;
          failwith "Substraction on bad types"
      )
    | [arg] -> (
        match arg with
          TDun -> PDSub, args
        | TInt -> PISub, args
        | _ ->
          debug "[liqprim_to_loveprim] Type %a is insufficient to guess the correct substraction\
                 primitive."
            Love_type.pretty arg;
          failwith "Cannot infer correct substraction primitive"
      )
    | [] -> failwith "Type of substraction cannot be inferred from no arguments."
    | _ ->  failwith "Too many arguments"
  )
  | Prim_mul -> (
    debug "[liqprim_to_loveprim] Multiplication@.";
    match args with
      [t1; t2] -> (
        match t1, t2 with
          TInt, TInt -> PIMul, args
        | TDun, (TInt | TVar _) -> PDIMul, [TDun; TInt]
        | (TInt | TVar _), TDun -> PIDMul, [TInt; TDun]
        | _,_ ->
          debug "[liqprim_to_loveprim] Forbidden multiplication on %a and %a."
            Love_type.pretty t1 Love_type.pretty t2;
          failwith "Substraction on bad types"
      )
    | [t] -> (
      match t with
      | TDun -> PDIMul, args
      | _ ->
        debug "[liqprim_to_loveprim] Type %a is insufficient to guess the correct primitive."
          Love_type.pretty t;
        failwith "Cannot infer correct multiplication primitive"
    )
    | [] -> failwith "Type of multiplication cannot be inferred from no arguments"
    | _ -> failwith "Too many arguments"
  )
  | Prim_ediv -> (
    debug "[liqprim_to_loveprim] Multiplication@.";
    match args with
      [t1; t2] -> (
        match t1, t2 with
          TInt, (TInt | TVar _) -> PIDiv, [TInt; TInt]
        | TDun, TInt          -> PDIDiv, args
        | (TDun | TVar _), TDun -> PDDiv, [TDun; TDun]
        | _,_ ->
          debug "[liqprim_to_loveprim] Forbidden division on %a and %a."
            Love_type.pretty t1 Love_type.pretty t2;
          failwith "Substraction on bad types"
      )
    | [t] -> (
        match t with
        | TInt -> PIDiv, args
        | _ ->
          debug "[liqprim_to_loveprim] Type %a is insufficient to guess the correct primitive."
            Love_type.pretty t;
          failwith "Cannot infer correct division primitive"
      )
    | [] -> failwith "Type of division cannot be inferred from no arguments"
    | _ -> failwith "Too many arguments"
  )
  | Prim_map_find -> (
      debug "[liqprim_to_loveprim] Map.find@.";
      match args with
        [_;TMap _] -> PMFind, args
      | [_;TBigMap _ ] -> PBMFind, args
      | [_;t] -> failwith (Format.asprintf "Bad argument type %a for Map.find" Type.pretty t)
      | [] | [_] -> failwith "Not enough arguments for Map.find"
      | l -> failwith (Format.asprintf "Too many arguments (%i) for Map.find" (List.length l))
    )
  | Prim_map_add  -> (
      debug "[liqprim_to_loveprim] Map.add@.";
      match args with
        [_;_;TMap _] -> PMAdd, args
      | [_;_;TBigMap _ ] -> PBMAdd, args
      | [] | [_] |[_;_] -> failwith "Not enough arguments for Map.add"
      | _ -> failwith "Too many arguments for Map.add"
    )
  | Prim_map_remove -> (
      debug "[liqprim_to_loveprim] Map.remove@.";
      match args with
        [_;TMap _] -> PMRemove, args
      | [_;TBigMap _ ] -> PBMRemove, args
      | [] | [_] -> failwith "Not enough arguments for Map.remove"
      | _ -> failwith "Too many arguments for Map.remove"
    )
  | Prim_map_mem -> (
      debug "[liqprim_to_loveprim] Map.mem@.";
      match args with
        [_;TMap _] -> PMMem, args
      | [_;TBigMap _ ] -> PBMMem, args
      | [] | [_] -> failwith "Not enough arguments for Map.mem"
      | _ -> failwith "Too many arguments for Map.mem"
    )
  | Prim_map_size -> (
      debug "[liqprim_to_loveprim] Map.size@.";
      match args with
        [TMap _] -> PMCard, args
      | [TBigMap _ ] -> PBMCard, args
      | [] -> failwith "Not enough arguments for Map.size"
      | _ -> failwith "Too many arguments for Map.size"
    )

  | Prim_map_update -> assert false (* not a love primitive, treated elsewhere *)

  | Prim_set_add -> debug "[liqprim_to_loveprim] Set.add@."; PSAdd, args
  | Prim_set_remove -> debug "[liqprim_to_loveprim] Set.remove@."; PSRemove, args
  | Prim_set_mem -> debug "[liqprim_to_loveprim] Set.mem@."; PSMem, args
  | Prim_set_size -> debug "[liqprim_to_loveprim] Set.size@."; PSCard, args
  | Prim_set_update -> assert false (* not a love primitive, treated elsewhere *)
  | Prim_Some -> assert false (* done elsewhere *)

  | Prim_list_size -> debug "[liqprim_to_loveprim] List.size@."; PLLength, args
  | Prim_list_rev  -> debug "[liqprim_to_loveprim] List.rev@."; PLRev, args
  | Prim_create_account -> debug "[liqprim_to_loveprim] PACreate@."; PACreate, args
  | Prim_blake2b -> debug "[liqprim_to_loveprim] PCBlake2b@."; PCBlake2b, args
  | Prim_sha256 -> debug "[liqprim_to_loveprim] Sha256@."; PCSha256, args
  | Prim_sha512 -> debug "[liqprim_to_loveprim] Sha512@."; PCSha512, args
  | Prim_hash_key -> debug "[liqprim_to_loveprim] Hashkey@."; PCHashKey, args
  | Prim_check -> debug "[liqprim_to_loveprim] PCCheck@."; PCCheck, args
  | Prim_default_account -> debug "[liqprim_to_loveprim] Default@."; PADefault, args
  | Prim_set_delegate -> debug "[liqprim_to_loveprim] SetDelegate@."; PCSetDeleg, args
  | Prim_address -> debug "[liqprim_to_loveprim] Address@."; PCAddress, args
  | Prim_pack -> debug "[liqprim_to_loveprim] Pack@."; PBPack, args
  | Prim_Cons -> debug "[liqprim_to_loveprim] (::)@."; PLCons, args
  | Prim_or -> (
      debug "[liqprim_to_loveprim] Or@.";
      match args with
        [t1; t2] -> (
          match t1, t2 with
          | TBool, (TBool | TVar _ )
          | TVar _ , TBool -> Love_primitive.PBOr, [TBool; TBool]
          | TInt, (TInt | TVar _ )
          | TVar _ , TInt -> PIOr, [TInt; TInt]
          | _,_ -> failwith "Bad arguments for operator or"
        )
      | [t] -> (
          match t with
            TBool -> PBOr, args
          | TInt -> PIOr, args
          | _ -> failwith "Bad arguments for operator or"
        )
      | [] -> failwith "Cannot infer correct Or primitive without argument"
      | _ -> failwith "Too many arguments"
    )
  | Prim_and -> (
      debug "[liqprim_to_loveprim] And@.";
      match args with
        [t1; t2] -> (
          match t1, t2 with
          | TBool, (TBool | TVar _ )
          | TVar _ , TBool -> Love_primitive.PBAnd, [TBool; TBool]
          | TInt, (TInt | TVar _ )
          | TVar _ , TInt -> PIAnd, [TInt; TInt]
          | _,_ -> failwith "Bad arguments for operator and"
        )
      | [t] -> (
          match t with
            TBool -> PBAnd, args
          | TInt -> PIAnd, args
          | _ -> failwith "Bad arguments for operator and"
        )
      | [] -> failwith "Cannot infer correct And primitive without argument"
      | _ -> failwith "Too many arguments"
    )
  | Prim_xor -> (
      debug "[liqprim_to_loveprim] Primitive Xor";
      match args with
        [t1; t2] -> (
          match t1, t2 with
          | TBool, (TBool | TVar _ )
          | TVar _ , TBool -> Love_primitive.PBXor, [TBool; TBool]
          | TInt, (TInt | TVar _ )
          | TVar _ , TInt -> PIXor, [TInt; TInt]
          | _,_ -> failwith "Bad arguments for operator xor"
        )
      | [t] -> (
          match t with
            TBool -> PBXor, args
          | TInt -> PIXor, args
          | _ -> failwith "Bad arguments for operator xor"
        )
      | [] -> failwith "Cannot infer correct Xor primitive without argument"
      | _ -> failwith "Too many arguments"
    )
  | Prim_not -> (
    debug "[liqprim_to_loveprim] Not@.";
    match args with
      [TBool] -> Love_primitive.PBNot, args
    | [TInt] -> PINot, args
    | _ -> failwith "Bad arguments for operator not"
  )
  | Prim_abs -> PIAbs, args
  | Prim_is_nat -> assert false (* done elsewhere *)
  | Prim_int -> assert false (* done elsewhere *)
  | Prim_neg -> PINeg, args
  | Prim_lsr -> PLsr, args
  | Prim_lsl -> PLsl, args

  | Prim_exec _ -> assert false (* done elsewhere *)

  | Prim_bytes_size -> PBLength, args
  | Prim_string_size -> PSLength, args

  | Prim_slice -> (
    debug "[liqprim_to_loveprim] Slice@.";
    match args with
      [] -> failwith "Bad number of arguments for Slice"
    | _ -> let last = List.hd @@ List.rev args in
      match last with
      | TString -> Love_primitive.PSSlice, args
      | TBytes -> PBSlice, args
      | _ -> failwith "Bad argument for slice"
  )
  | Prim_bytes_sub -> PBSlice, args
  | Prim_string_sub -> PSSlice, args

  | Prim_concat ->  assert false (* must be treated elsewhere *)
  (*(
    match typ with
      TString -> PSConcat
    | TBytes -> PBConcat
    | _ -> failwith "Concat on non string and non byte type"
                                   ) *)
  | Prim_concat_two -> assert false (* must be treated elsewhere *)
  | Prim_string_concat -> PSConcat, args
  | Prim_bytes_concat -> PBConcat, args

let liqprimfold_to_loveexp
    (env : env)
    (prim : LiquidTypes.prim_fold)
    (arg_name : string)
    (arg : Typed.Exp.t)
    (arg_typ : Love_type.t)
    (acc : Typed.Exp.t)
    (acc_typ : Love_type.t)
    (body_maker: env -> typed_exp -> Typed.Exp.t * Love_type.t)
    (body : typed_exp)
  : Love_ast.Typed.Exp.t * Love_type.t =
  let v i = mk_var @@ Love_ident.create_id i in
    match prim with
    | Prim_map_iter ->
      debug "[liqprimfold_to_loveexp] Map.iter@.";
      let cprim, t1, t2 =
        match arg_typ with
          TMap (t1, t2) -> Love_primitive.PMIter, t1, t2
        | TBigMap (t1, t2) -> Love_primitive.PBMIter, t1, t2
        | _ ->
          failwith (
            Format.asprintf "Type %a incommpatible with iteration on maps" Love_type.pretty arg_typ)
      in
      let env = Compil_utils.add_var arg_name (TTuple [t1; t2]) env
      in
      let bdy, typ = body_maker env body in
      debug "[liqprimfold_to_loveexp] Body type = %a@." Love_type.pretty typ;
      mk_apply
        (mk_primitive_lambda
           cprim
           ((t1 @=> t2 @=> TUnit) @=> arg_typ @=> TUnit))
        [Compil_utils.put_in_arrow
            ["##key", t1; "##bind", t2]
            (mk_let
               (mk_pvar arg_name)
               (mk_tuple [v "##key"; v "##bind"] )
               bdy
            );
         arg], typ
    | Prim_set_iter ->
      debug "[liqprimfold_to_loveexp] Set.iter@.";
      let t =
        match arg_typ with
          TSet t -> t
        | _ ->
          failwith (
            Format.asprintf "Type %a incommpatible with iteration on sets" Love_type.pretty arg_typ)
      in
      let env = Compil_utils.add_var arg_name t env
      in
      let bdy, typ = body_maker env body in
      debug "[liqprimfold_to_loveexp] Body type = %a@." Love_type.pretty typ;
      mk_apply
        (mk_primitive_lambda Love_primitive.PSIter ((t @=> TUnit) @=> TSet t))
        [mk_lambda (mk_pvar arg_name) bdy t; arg], typ
    | Prim_list_iter ->
      debug "[liqprimfold_to_loveexp] List.iter@.";
      let t =
        match arg_typ with
          TList t -> t
        | _ ->
          failwith (
            Format.asprintf "Type %a incommpatible with iteration on lists" Love_type.pretty arg_typ)
      in
      let env = Compil_utils.add_var arg_name t env
      in
      let bdy, typ = body_maker env body in
      debug "[liqprimfold_to_loveexp] Body type = %a@." Love_type.pretty typ;
      mk_apply
        (mk_primitive_lambda Love_primitive.PLIter ((t @=> TUnit) @=> TList t @=> TUnit))
        [mk_lambda (mk_pvar arg_name) bdy t; arg], typ
    | Prim_map_fold ->
      debug "[liqprimfold_to_loveexp] Map.fold@.";
      let cprim, t1, t2 =
        match arg_typ with
          TMap (t1, t2) -> Love_primitive.PMFold, t1, t2
        | TBigMap (t1, t2) -> PBMFold, t1, t2
        | _ ->
          failwith (
            Format.asprintf "Type %a incommpatible with folds on maps" Love_type.pretty arg_typ)
      in
      let vars = ["##key", t1; "##bind", t2; "##acc", acc_typ] in
      let env = Compil_utils.add_var arg_name (TTuple [TTuple [t1; t2]; acc_typ]) env
      in
      let bdy, typ = body_maker env body in
      debug "[liqprimfold_to_loveexp] Body type = %a@." Love_type.pretty typ;
      let prim =
        mk_primitive_lambda
          cprim
          ((t1 @=> t2 @=> acc_typ @=> acc_typ) @=> arg_typ @=> acc_typ @=> acc_typ) in
      debug "[liqprimfold_to_loveexp] Primitive = %a@." Typed.Exp.print prim ;
      mk_apply
        prim
        [Compil_utils.put_in_arrow
           vars
           (mk_let
              (mk_pvar arg_name)
              (mk_tuple [mk_tuple [v "##key"; v "##bind"]; v "##acc"])
              bdy
           );
         arg;
         acc], typ
    | Prim_set_fold ->
      debug "[liqprimfold_to_loveexp] Set.fold@.";
      let t =
        match arg_typ with
          TSet t -> t
        | _ ->
          failwith (
            Format.asprintf "Type %a incommpatible with fold on sets" Love_type.pretty arg_typ)
      in
      let vars = ["##key", t; "##acc", acc_typ] in
      let env =
          Compil_utils.add_var
            arg_name
            (TTuple [t; acc_typ])
            env
      in
      let bdy, typ = body_maker env body in
      debug "[liqprimfold_to_loveexp] Body type = %a@." Love_type.pretty typ;
      mk_apply
        (mk_primitive_lambda
           Love_primitive.PSFold
           ((t @=> acc_typ @=> acc_typ) @=> TSet t @=> acc_typ @=> acc_typ))
        [Compil_utils.put_in_arrow
           vars
           (mk_let
              (mk_pvar arg_name)
              (mk_tuple [v "##key";v "##acc"])
              bdy
           );
         arg;
         acc], typ
    | Prim_list_fold ->
      debug "[liqprimfold_to_loveexp] List.fold@.";
      let t =
        match arg_typ with
          TList t -> t
        | _ ->
          failwith (
            Format.asprintf "Type %a incommpatible with fold on lists" Love_type.pretty arg_typ)
      in
      let vars = ["##key", t; "##acc", acc_typ] in
      let env = Compil_utils.add_var arg_name (TTuple [t; acc_typ]) env in
      let bdy, typ = body_maker env body in
      debug "[liqprimfold_to_loveexp] Body type = %a@." Love_type.pretty typ;
      mk_apply
        (mk_primitive_lambda
           Love_primitive.PLFold
           ((t @=> acc_typ @=> acc_typ) @=> TList t @=> acc_typ @=> acc_typ))
        [Compil_utils.put_in_arrow
           vars
           (mk_let
              (mk_pvar arg_name)
              (mk_tuple [v "##key";v "##acc"])
              bdy
           );
         arg;
         acc], t
    | Prim_coll_iter
    | Prim_coll_fold -> failwith "Generic iterators forbidden"

let liqprimmap_to_loveexp
    (env : env)
    (prim : LiquidTypes.prim_map)
    (arg_name : string)
    (body_maker : env -> typed_exp -> Typed.Exp.t * Love_type.t)
    (body : typed_exp)
    arg
    arg_typ =
  let v i = mk_var @@ Love_ident.create_id i in
  match prim with
  | Prim_map_map ->
    let cprim, t1, t2, tbuilder =
      match arg_typ with
        TMap (t1, t2) -> Love_primitive.PMMap, t1, t2, (fun t -> TMap (t1, t))
      | TBigMap (t1, t2) -> Love_primitive.PBMMap, t1, t2, (fun t -> TBigMap (t1, t))
      | _ ->
          failwith (
            Format.asprintf "Type %a incommpatible with map on maps" Love_type.pretty arg_typ)
    in
    let vars = ["##key", t1; "##bnd", t2] in
    let env = Compil_utils.add_var arg_name (TTuple [t1; t2]) env in
    let bdy, typ = body_maker env body in
    mk_apply
      (mk_primitive_lambda
         cprim
         ((t1 @=> t2 @=> typ) @=> arg_typ @=> tbuilder typ)
      )
      [Compil_utils.put_in_arrow
         vars
         (mk_let
            (mk_pvar arg_name)
            (mk_tuple [v "##key";v "##bnd"])
            bdy
         );
       arg
      ], TMap (t1, typ)
  | Prim_list_map ->
      let t =
        match arg_typ with
          TList t -> t
        | _ ->
          failwith (
            Format.asprintf "Type %a incommpatible with map on lists" Love_type.pretty arg_typ)
      in
      let env = Compil_utils.add_var arg_name t env in
      let bdy, typ = body_maker env body in
      mk_apply
        (mk_primitive_lambda
           Love_primitive.PLMap
           ((t @=> typ) @=> TList t @=> TList typ))
        [mk_lambda (mk_pvar arg_name) bdy t; arg], TList typ
  | Prim_coll_map -> failwith "Generic map forbidden"

let liqprimmapfold_to_loveexp
    (env : env)
    prim
    (arg_name : string)
    (body_maker : env -> typed_exp -> Typed.Exp.t * Love_type.t)
    (body : typed_exp)
    arg
    arg_typ
    acc
    acc_typ =
  let v i = mk_var @@ Love_ident.create_id i in
  match prim with
  | Prim_map_map_fold ->
    let cprim, t1, t2, tbuilder =
      match arg_typ with
        TMap (t1, t2) -> Love_primitive.PMMapFold, t1, t2, (fun t -> TMap (t1,t))
      | TBigMap (t1, t2) -> Love_primitive.PBMMapFold, t1, t2, (fun t -> TBigMap (t1,t))
      | _ ->
          failwith (
            Format.asprintf "Type %a incommpatible with map on maps" Love_type.pretty arg_typ)
    in
    let vars = ["##key", t1; "##bnd", t2; "##acc", acc_typ] in
    let env =
        Compil_utils.add_var arg_name (TTuple [TTuple [t1; t2]; acc_typ]) env in
    let bdy, typ = body_maker env body in
    let typ_newbnd, typ_acc =
      match typ with
        TTuple [t1; t2] -> t1, t2
      | t ->
        debug
          "[liqprimmapfold_to_loveexp] Return type should be a pair, but it is %a"
          Love_type.pretty t;
        failwith "Badly typed mapfold body"
    in
    mk_apply
      (mk_primitive_lambda
         cprim
         ((t1 @=> t2 @=> acc_typ @=> TTuple [typ_newbnd; typ_acc])
          @=> arg_typ @=> typ_acc @=> TTuple [tbuilder typ_newbnd; typ_acc]))
      [Compil_utils.put_in_arrow
         vars
         (mk_let
            (mk_pvar arg_name)
            (mk_tuple [mk_tuple [v "##key";v "##bnd"]; v "##acc"])
            bdy
         );
       arg;
       acc
      ], TTuple [TMap (t1, typ_newbnd); typ_acc]
  | Prim_list_map_fold ->
      let t =
        match arg_typ with
          TList t -> t
        | _ ->
          failwith (
            Format.asprintf "Type %a incommpatible with map on lists" Love_type.pretty arg_typ)
      in
      let vars = ["##elt", t; "##acc", acc_typ] in
      let env = Compil_utils.add_var arg_name (TTuple [t; acc_typ]) env in
      let bdy, typ = body_maker env body in
      let typ_newbnd, typ_acc =
        match typ with
          TTuple [t1; t2] -> t1, t2
        | t ->
          debug
            "[liqprimmapfold_to_loveexp] Return type should be a pair, but it is %a"
            Love_type.pretty t;
          failwith "Badly typed mapfold body"
      in
      mk_apply
        (mk_primitive_lambda
           Love_primitive.PLMapFold
           ((t @=> typ_acc @=> TTuple [typ_newbnd; typ_acc])
            @=> TList t @=> typ_acc @=> TTuple [TList typ_newbnd; typ_acc]))
        [Compil_utils.put_in_arrow
           vars
           (mk_let
              (mk_pvar arg_name)
              (mk_tuple [v "##elt"; v "##acc"])
              bdy
           );
         arg;
         acc
        ], TTuple [TList typ_newbnd; typ_acc]
  | Prim_coll_map_fold -> failwith "Generic map fold forbidden"


let rec liqconst_to_loveexp ?typ (env : env) (c : (datatype, typed) exp const)
  : Typed.Exp.t * Love_type.t =
  let ltl ?typ = liqconst_to_loveexp ?typ env in
  let () = match typ with
      None ->
      debug "[liqconst_to_loveexp] Warning : calling const to exp with no type.@."
    | Some t ->
      debug "[liqconst_to_loveexp] Calling const to exp with type %a.@." Love_type.pretty t in
  let res =
    match c with
      CUnit   -> mk_const @@ mk_cunit (), TUnit
    | CBool b -> mk_const @@ mk_cbool b, TBool
    | CInt i  -> mk_const @@ mk_cint i.integer, TInt
    | CNat n  -> mk_const @@ mk_cint n.integer, TInt
    | CTez {tezzies;mutez} -> (
        let str =
          let mutez = match mutez with
            | Some mutez -> mutez
            | None  -> "000000"
          in
          tezzies ^ mutez
        in
        match Tez_repr.of_string str with
          None -> failwith (Format.asprintf "%s is not a correct dun amount" str)
        | Some d -> mk_const @@ mk_cdun d
      ), TDun
    | CTimestamp s -> (
        debug "[liqconst_to_loveexp] CTimestamp : %s@." s;
        match Script_timestamp_repr.of_string s with
          None -> failwith "Timestamp has no integer representation"
        | Some ts -> mk_const @@ mk_ctimestamp ts
      ), TTimestamp
    | CString s -> mk_const @@ mk_cstring s, TString
    | CBytes b -> mk_const @@ mk_cbytes (MBytes.of_string_slice b 0 (String.length b - 1)), TBytes
    | CKey k -> (
      match Signature.Public_key.of_b58check_opt k with
          None -> failwith (Format.asprintf "Key %s is invalid" k)
        | Some k -> mk_const @@ mk_ckey k, TKey
    )
    | CSignature s -> (
      match Signature.of_b58check_opt s with
          None -> failwith (Format.asprintf "Signature %s is invalid" s)
        | Some s -> mk_const @@ mk_csig s, TSignature
    )
    | CTuple ([] | [_] as l) ->
      debug "[liqconst_to_loveexp] Error : tuple has %i elements@." (List.length l);
      failwith "CTuple has not enough elements"
    | CTuple l -> (
        match typ with
          None ->
          let cl, tl = List.split @@ List.map ltl l
          in
          mk_tuple cl, TTuple tl (* Set as a tuple expression because it may contain
                                    polymorphic types *)
        | Some ((TTuple tl) as ty) ->
          debug "[liqconst_to_loveexp] Tuple of type %a matched with tuple with %i elements@."
            Love_type.pretty ty (List.length l);
          let tuple_elt, tup_typ = (
            List.fold_left2
              (fun acc elt typ -> ltl ~typ elt :: acc)
              []
              l
              tl) |> List.rev |> List.split
          in
          mk_tuple tuple_elt, TTuple tup_typ
        | Some t ->
          debug "[liqconst_to_loveexp] Error : CTuple has type %a" Love_type.pretty t;
          failwith "CTuple has not the type tuple"
      )

    | CNone -> (
        match typ with
          None ->
          debug "[liqconst_to_loveexp] Making CNone with no type.";
          mk_none (), Love_type.type_cnone
        | Some ((TOption t) as res)  -> mk_none ~typ:t (), res
        | Some t ->
          debug "[liqconst_to_loveexp] Error : CNone has type %a" Love_type.pretty t;
          failwith "CNone has not the type option"
      )
    | CSome c ->
      let typ =
        match typ with
          None -> None
        | Some (TOption t) -> Some t
        | Some t ->
          debug "[liqconst_to_loveexp] Error : CSome has type %a"
            Love_type.pretty t;
          failwith "CSome has not the type option" in
      let c, t = ltl ?typ c in mk_some c, TOption t

    | CMap l ->  (
        let empty, typ, tkey, telt =
          match typ, l with
            None,[] ->
            mk_emptyset (),
            Love_type.type_empty_map,
            TVar Love_type.tvmkey,
            TVar Love_type.tvmbnd
          | None, (hdk, hdb) :: _ ->
            let _, tk = liqconst_to_loveexp env hdk in (* todo : done twice on list head *)
            let _, tb = liqconst_to_loveexp env hdb in (* todo : done twice on list head *)
            mk_emptymap ~typ_key:tk ~typ_bnd:tb (), TMap (tk,tb), tk, tb
          | Some ((TMap (typ_key,typ_bnd)) as ltyp),_ ->
            mk_emptymap ~typ_key ~typ_bnd (),
            ltyp,
            typ_key,
            typ_bnd
          | Some t,_ ->
            debug "[liqconst_to_loveexp] Error : CMap has type %a" Love_type.pretty t;
            failwith "CMap has not the type Map"
        in (
          List.fold_left
            (fun map (new_key,new_bnd) ->
               mk_apply (mk_primitive_lambda PMAdd (tkey @=> telt @=> typ @=> typ))
                 [fst @@ liqconst_to_loveexp ~typ:tkey env new_key;
                  fst @@ liqconst_to_loveexp ~typ:telt env new_bnd;
                  map]
            )
            empty
            l), typ
      )

    | CBigMap l ->  (
        let empty, typ, tkey, telt =
          match typ, l with
            None,[] ->
            mk_emptyset (),
            Love_type.type_empty_bigmap,
            TVar Love_type.tvmkey,
            TVar Love_type.tvmbnd
          | None, (hdk, hdb) :: _ ->
            let _, tk = liqconst_to_loveexp env hdk in (* todo : done twice on list head *)
            let _, tb = liqconst_to_loveexp env hdb in (* todo : done twice on list head *)
            mk_emptymap ~typ_key:tk ~typ_bnd:tb (), TMap (tk,tb), tk, tb
          | Some ((TBigMap (typ_key,typ_bnd)) as ltyp),_ ->
            mk_emptybigmap ~typ_key ~typ_bnd (),
            ltyp,
            typ_key,
            typ_bnd
          | Some t,_ ->
            debug "[liqconst_to_loveexp] Error : CBigMap has type %a" Love_type.pretty t;
            failwith "CBigMap has not the type BigMap"
        in (
          List.fold_left
            (fun bm (new_key,new_bnd) ->
               mk_apply (mk_primitive_lambda PBMAdd (tkey @=> telt @=> typ @=> typ))
                 [fst @@ liqconst_to_loveexp ~typ:tkey env new_key;
                  fst @@ liqconst_to_loveexp ~typ:telt env new_bnd;
                  bm]
            )
            empty
            l), typ
      )
    | CList [] -> (
        match typ with
          None -> mk_enil (), Love_type.type_empty_list
        | Some ((TList t) as ltyp) -> mk_enil ~typ:t (), ltyp
        | Some t ->
          debug "[liqconst_to_loveexp] Error : Empty CList has type %a" Love_type.pretty t;
          failwith "Empty CList has not the type List"
      )
    | CList l ->
      let new_l, t =
        List.fold_left
          (fun (acc_l, acc_t) elt ->
             match acc_t with
               TVar _ -> let e, t = ltl elt in e :: acc_l, t
             | _ ->
               let e, t = ltl ~typ:acc_t elt in
               match acc_t, t with
               | TForall _, TForall _ -> e :: acc_l, t
               | TForall _, _ ->
                 let new_acc_l =
                   List.map (fun e -> mk_tapply e t) acc_l in
                 (e :: new_acc_l), t
               | _,_ -> e :: acc_l, t
          )
          ([], TVar (Love_type.fresh_typevar ()))
          l
      in mk_list (List.rev new_l), TList t
    | CSet l -> (
        let empty, typ, telt =
          match typ, l with
            None,[] -> mk_emptyset (), Love_type.type_empty_set, TVar Love_type.tvset
          | None, hd :: _ ->
            let _, thd = liqconst_to_loveexp env hd in (* todo : done twice on list head *)
            mk_emptyset ~typ:thd (), TSet thd, thd
          | Some ((TSet t) as ltyp),_ -> mk_emptyset ~typ:t (), ltyp, t
          | Some t,_ ->
            debug "[liqconst_to_loveexp] Error : CSet has type %a" Love_type.pretty t;
            failwith "CSet has not the type Set"
        in (
          List.fold_left
            (fun set new_val ->
               mk_apply (mk_primitive_lambda PSAdd (telt @=> typ @=> typ))
                 [fst @@ liqconst_to_loveexp ~typ:telt env new_val;
                  set]
            )
            empty
            l), typ
      )

    | CLeft c ->
      let (c, t1),t2 =
        match typ with
          None -> liqconst_to_loveexp env c, TVar (Compil_utils.Tor.tor_typright)
        | Some (TUser (_, [typ; t2])) -> liqconst_to_loveexp ~typ env c, t2
        | Some _ -> failwith "Bad type for CLeft"
      in
      mk_tapply
      (mk_tlambda Compil_utils.Tor.tor_typright (mk_constr (Love_ident.create_id "Left") [c]))
      t2,
      TUser (Compil_utils.Tor.tor_typename, [t1; t2])
    | CRight c ->
      let (c, t2),t1 =
        match typ with
          None -> liqconst_to_loveexp env c, TVar (Compil_utils.Tor.tor_typleft)
        | Some (TUser (_, [t1; typ])) -> liqconst_to_loveexp ~typ env c, t1
        | Some _ -> failwith "Bad type for CRight"
      in
      mk_tapply
        (mk_tlambda Compil_utils.Tor.tor_typleft (mk_constr (Love_ident.create_id "Right") [c]))
        t1,
      TUser (Compil_utils.Tor.tor_typename, [t1; t2])

    | CKey_hash kh -> (
      match Signature.Public_key_hash.of_b58check_opt kh with
          None -> failwith (Format.asprintf "Keyhash %s is invalid" kh)
        | Some k -> mk_const @@ mk_ckeyhash k, TKeyHash
    )
    | CContract c ->
      failwith (Format.asprintf "Constant contracts (here %s) has no representation in Love." c)
    | CAddress a -> (
        match Contract_repr.of_b58check a with
          Ok add -> mk_const @@ mk_caddress add, TAddress
        | Error elist ->
          debug "[liqconst_to_loveexp] CAddress %s error : %a" a Error_monad.pp_print_error elist;
          failwith "Failing while building address"
      )

    | CRecord [] -> assert false
    | CRecord (((name, _) :: _) as l) -> (* May be source of errors on polymorphic records *)
      let id_name = string_to_ident name in
      let parent_typ =
        match Love_tenv.find_field id_name env with
          None -> debug "[liqconst_to_loveexp] Field %s is unknown" name;
          failwith "Unknown field"
        | Some {fparent; _} -> fparent
      in
      mk_record (
        List.map
          (fun (name, c) ->
             let (id_name : string Love_ident.t) = string_to_ident name in
             let typ =
               match Love_tenv.find_field id_name env with
                 None -> debug "[liqconst_to_loveexp] Field %s is unknown" name;
                 failwith "Unknown field "
               | Some {ftyp; _} -> ftyp
             in
             id_name, (fst @@ ltl ~typ c)
          )
          l
      ), parent_typ
    | CConstr (name, args) -> (* May be source of errors on polymorphic constrs *)
      debug "[liqconst_to_loveexp] Creating constant constructor %s@." name;
      let id_name = string_to_ident name in
      let t, targs =
        match Love_tenv.find_constr id_name env with
          None ->
          debug "[liqconst_to_loveexp] Constructor %s is unknown" name;
          failwith "Unknown constructor"
        | Some {cparent;cargs = [t];_} -> (* In liquidity, constructors arguments are tuples. *)
          cparent, t
        | _ -> assert false
      in mk_constr id_name [fst @@ ltl ~typ:targs args], t

    | CLambda {arg_name; arg_ty; body; ret_ty; recursive} ->
      failwith "CLambda forbidden"
  in
  let () = match typ with
      None ->
      debug
        "[liqconst_to_loveexp] Untyped const %a : %a.@."
        Typed.Exp.print (fst res) Love_type.pretty (snd res)
    | Some t ->
      debug
        "[liqconst_to_loveexp] Const %a : %a@."
        Typed.Exp.print (fst res) Love_type.pretty (snd res)
  in res
(** Some primitives need a special treatment done by this function  *)
and liqapply_to_loveexp env typ prim args : Typed.Exp.t * Love_type.t =
  let ltl = liqexp_to_loveexp env in
  match prim,args with
  | Prim_tuple_get, tuple :: index :: [] ->
    debug "[liqapply_to_loveexp] Creating tuple projection@.";
    let index = (*
          match ltl e with
            Typed.Exp.Const (CInt i) -> i
          | cst -> debug "[liqexp_to_loveexp] Tuple projections must have an integer as index.\n\
                          Index = %a@."  Typed.Exp.print cst;
            failwith "Tuple projections must have an integer as index@." in *)
      match index with
        {desc = Const {const = CInt i; _}; _}
      | {desc = Const {const = CNat i; _}; _} -> i.integer
      | sthg -> (
          debug
            "[liqapply_to_loveexp] Index is not a liquidity constant,\
             checking love representation@.";
          match fst @@ ltl sthg with
            Typed.Exp.Const (CInt i) -> i
          | cst ->
            debug "[liqapply_to_loveexp] Tuple projections must have an integer as index.\n\
                   Index = %a@."
              Typed.Exp.print cst;
            failwith "Tuple projections must have an integer as index@."
        )
    in
    let iindex = Z.to_int index in
    let check_int = Z.equal index (Z.of_int iindex) in
    debug "[liqapply_to_loveexp] Projection with index = %a@." Z.pp_print index;
    if check_int
    then
      let tup, ty = ltl tuple in
      debug
        "[liqapply_to_loveexp] Tuple %a : %a@." Typed.Exp.print tup Love_type.pretty ty;
      match ty with
        TTuple typ_list -> mk_projection tup iindex, List.nth typ_list iindex
      | t ->
        debug "[liqapply_to_loveexp] Tuple has type %a@." Love_type.pretty t;
        failwith "Bad tuple type"
    else failwith (Format.asprintf "Index %a is too big" Z.pp_print index)
  | Prim_tuple_get, ([] | _ :: []) -> failwith "Tuple projection cannot be currified"
  | Prim_tuple_get, l ->
    failwith (
      Format.sprintf "Tuple projection expects 2 arguments : here it is applied to %i" (List.length l)
    )

  | Prim_tuple_set, tuple :: index :: content :: [] ->
    debug "[liqapply_to_loveexp] Creating tuple update@.";
    let index = (*
          match ltl e with
            Typed.Exp.Const (CInt i) -> i
          | cst -> debug "[liqexp_to_loveexp] Tuple projections must have an integer as index.\n\
                          Index = %a@."  Typed.Exp.print cst;
            failwith "Tuple projections must have an integer as index@." in *)
      match index with
        {desc = Const {const = CInt i; _}; _} -> i.integer
      | {desc = Const {const = CNat i; _}; _} -> i.integer
      | sthg -> (
          debug
            "[liqapply_to_loveexp] Index is not a liquidity constant,\
             checking love representation@.";
          match fst @@ ltl sthg with
            Typed.Exp.Const (CInt i) -> i
          | cst ->
            debug "[liqapply_to_loveexp] Tuple projections must have an integer as index.\n\
                   Index = %a@."
              Typed.Exp.print cst;
            failwith "Tuple projections must have an integer as index@."
        )
    in
    let iindex = Z.to_int index in
    let check_int = Z.equal index (Z.of_int iindex) in
    debug "[liqapply_to_loveexp] Projection with index = %a@." Z.pp_print index;
    if check_int
    then
      let tup, typ = ltl tuple in
      let content, _ = ltl content in
      match typ with
        TTuple _ -> mk_update tup [iindex, content], typ
      | _ ->
        debug "[liqapply_to_loveexp] (update) Tuple has type %a@." Love_type.pretty typ;
        failwith "Bad updated tuple type"
    else failwith (Format.asprintf "Index %a is too big" Z.pp_print index)

  | Prim_tuple_set, ([] | _ :: [] | _ :: _ :: []) ->  failwith "Tuple update cannot be currified"
  | Prim_tuple_set, l ->
    failwith (
      Format.sprintf "Tuple update expects 3 arguments : here it is applied to %i" (List.length l)
    )
  | Prim_tuple,_ ->
    debug "[liqapply_to_loveexp] Creating a tuple@.";
    let args, typs = List.split @@ List.map ltl args in
    mk_tuple args, TTuple typs
  | Prim_Some, [arg] ->
    debug "[liqapply_to_loveexp] Creating Some@.";
    let e, t = ltl arg in
    mk_some e, TOption t

  | Prim_concat, l
  | Prim_concat_two, l ->
    debug "[liqapply_to_loveexp] Creating a concatenation@.";
    let ty = liqtype_to_lovetype env typ in
    let prim =
      match ty with
        TString -> Love_primitive.PSConcat
      | TBytes -> PBConcat
      | _ -> failwith "Concatenation is only possible on strings and bytes" in
    mk_apply
      (mk_primitive_lambda prim (ty @=> ty @=> ty))
      [mk_list @@ List.map (fun e -> fst @@ ltl e) l], ty

  | Prim_is_nat, [e] -> (
    (* if e >= 0 then Some e else None *)
      let lovee, te = ltl e in
      mk_if
        (mk_apply (mk_primitive_lambda PLe (te @=> te @=> TBool)) [lovee; mk_const @@ mk_cint Z.zero])
        (mk_some lovee)
        (mk_none ~typ:TInt ()), TOption TInt
    )
  | Prim_int, [cst] -> (
      debug "[liqapply_to_loveexp] Creating a cast@.";
      match liqexp_to_loveexp env cst with
        Const (CInt _) as c, t -> c, t
      | c, t -> debug "[liqapply_to_loveexp] Unsafe cast of %a to an integer@."
               Typed.Exp.print c;
        c, t
    )
  | Prim_int, _ -> failwith "Bad arguments for Prim_int"
  | Prim_set_update, [elt; b; set] ->
    let elt,key = ltl elt in
    let b,_bool = ltl b in
    let set,t = ltl set in
    let prim_typ = key @=> t @=> t in
    mk_if
      b
      (mk_apply (mk_primitive_lambda PSAdd    prim_typ) [elt; set])
      (mk_apply (mk_primitive_lambda PSRemove prim_typ) [elt; set]), t
  | Prim_set_update, _ -> failwith "Bad number of arguments for Prim_set_update"
  | Prim_map_update, [elt; valopt; map] ->
    let elt, telt = ltl elt in
    let valopt, tval = ltl valopt in
    let map, t = ltl map in
    let prim_add, prim_rem =
      match t with
        TMap _ -> Love_primitive.(PMAdd, PMRemove)
      | TBigMap _ -> PBMAdd, PBMRemove
      | t ->
        debug "[liqapply_to_loveexp] Incorrect type %a for map" Love_type.pretty t;
        failwith "Incorrect map type"
    in
    let prim_typ = telt @=> TMap (telt, tval) @=> TMap (telt, tval) in
    mk_match
      valopt
      [mk_pnone (),
       mk_apply (mk_primitive_lambda prim_rem prim_typ) [elt; map];

       mk_psome (mk_pvar "##v"),
       mk_apply (mk_primitive_lambda prim_add prim_typ)
         [elt; mk_var (Love_ident.create_id "##v"); map]
      ], t
  | Prim_map_update, _ -> failwith "Bad number of arguments for Prim_map_update"
  | Prim_Left, [arg] ->
    let a, t = ltl arg in
    let t2 =
      match typ with
        Tor (_, t2) -> liqtype_to_lovetype env t2
      | _ -> assert false
    in
    mk_tapply
      (mk_tlambda Compil_utils.Tor.tor_typright (mk_constr (Love_ident.create_id "Left") [a]))
      t2,
    TUser (Compil_utils.Tor.tor_typename, [t; t2])
  | Prim_Right, [arg] ->
    let a, t = ltl arg in
    let t1 =
      match typ with
        Tor (t1, _) -> liqtype_to_lovetype env t1
      | _ -> assert false
    in
    mk_tapply
      (mk_tlambda Compil_utils.Tor.tor_typleft (mk_constr (Love_ident.create_id "Right") [a]))
      t1,
    TUser (Compil_utils.Tor.tor_typename, [t1; t])
  | (Prim_self | Prim_exec _), _ -> assert false (* Done before *)

  | _ ->
    debug "[liqapply_to_loveexp] Love primitive@.";
    let love_args_typ =
      List.fold_left
        (fun acc a ->
           let arg, t = ltl a in
           debug "[liqapply_to_loveexp] Primitive argument is %a@." Typed.Exp.print arg;
           (arg, t) :: acc)
        []
        args |> List.rev
    in
    let first_version_of_typs = snd (List.split love_args_typ) in
    let prim, lovetlist = liqprim_to_loveprim env prim first_version_of_typs in
    let prim_typ = Love_primitive.type_of prim in
    debug "[liqapply_to_loveexp] Applying correct types based on %a@." Love_type.pretty prim_typ;
    let love_args_typ = Compil_utils.merge_args_with_funtyp love_args_typ prim_typ in
    let loveargs, lovetlist = List.split love_args_typ in
    let tprim = Love_primitive.type_of prim in
    debug "[liqapply_to_loveexp] Type of prim is %a, with %i args.@."
      Love_type.pretty tprim
      (List.length loveargs);
    debug "[liqapply_to_loveexp] Args = %a.@."
      (Format.pp_print_list Typed.Exp.print) loveargs;
    let t = Compil_utils.return_type_with_args prim_typ lovetlist
    in
    debug "[liqapply_to_loveexp] Return type if primitive is %a.@."
      Love_type.pretty t;
    mk_apply
      (mk_primitive_lambda prim @@ Compil_utils.arrow_from_tlist lovetlist)
      loveargs, t

and liqexp_to_loveexp (env : env) (e : typed_exp) : Typed.Exp.t * Love_type.t =
  let exp, t =
    let ltl = liqexp_to_loveexp env in
    match e.desc with
      Let { bnd_var = {nname; _}; inline; bnd_val; body} ->
      debug "[liqexp_to_loveexp] let %s = ...@." nname;
      let bnd_val,btyp = ltl bnd_val in
      debug "[liqexp_to_loveexp] let %s = %a in...@." nname Typed.Exp.print bnd_val;
      let body, body_typ =
        liqexp_to_loveexp (Compil_utils.add_var nname btyp env) body in
      debug "[liqexp_to_loveexp] let %s = %a in %a@." nname Typed.Exp.print bnd_val Typed.Exp.print body;
      mk_let
        (Love_ast_utils.mk_pvar nname)
        bnd_val
        body, body_typ
    | Var v -> (
        debug "[liqexp_to_loveexp] Creating Var (%s)@." v;
        let vi = string_to_ident v in
        match Love_tenv.find_var vi env with
          None -> failwith ("Unknown variable " ^ v)
        | Some (_k,t) -> mk_var vi, t
      )
    | SetField {record; field; set_val} ->
      debug "[liqexp_to_loveexp] Creating a SetField@.";
      let rcd, typ = ltl record in
      mk_set_field
        rcd
        [(string_to_ident field), fst @@ ltl set_val], typ
    | Project {field; record} ->
      debug "[liqexp_to_loveexp] Creating a Projection@.";
      let fid = string_to_ident field in
      let typ =
        match Love_tenv.find_field fid env with
          None -> failwith ("Unknown field " ^ field)
        | Some {ftyp;_} -> ftyp
      in mk_get_field (fst @@ ltl record) fid, typ
    | Const {ty; const} ->
      debug "[liqexp_to_loveexp] Creating a Const@.";
      let typ = liqtype_to_lovetype env ty in
      let res = liqconst_to_loveexp ~typ env const in
      debug "[liqexp_to_loveexp] Const %a created@." Typed.Exp.print (fst @@ res); res
    | Apply {prim = Prim_exec _; args} -> (
        debug "[liqexp_to_loveexp] Creating a lambda application@.";
        match args with
          [] | _ :: [] -> assert false
        | fct :: args -> ((*
            let fct', ftyp = ltl fct in
            debug "[liqexp_to_loveexp] Function %a@." Typed.Exp.print fct';
            (* If fct is polymorphic, we must apply the correct type arguments *)
            let typ_fct = liqtype_to_lovetype env fct.ty in
            let eargs, targs = List.split (List.map ltl args) in

            let aliases = search_aliases typ_fct (Compil_utils.arrow_from_tlist targs) in
            if TypeVarMap.is_empty aliases
            then (
              debug "[liqexp_to_loveexp] This is not a polymorphic function@.";
              (mk_apply fct' eargs),
              Compil_utils.return_type_with_args ftyp targs
            )
            else (
              debug "[liqexp_to_loveexp] This is a polymorphic function@.";
              TypeVarMap.fold
                (fun tv ty exp -> (mk_tapply (mk_tlambda tv exp) ty))
                aliases
                (mk_apply fct' eargs),
              Compil_utils.return_type_with_args ftyp targs
            )
          )*)
            let fct', ftyp = ltl fct in
            debug "[apply_types] Function %a : %a" Typed.Exp.print fct' Love_type.pretty ftyp;
            let eargs, targs = List.split (List.map ltl args) in
            debug "[apply_types] Arguments : %a" (Format.pp_print_list Typed.Exp.print) eargs;
            mk_apply fct' eargs, Compil_utils.return_type_with_args ftyp targs
          )
      )
    | Apply {prim = Prim_self; _} -> (
        match e.ty with
          Tcontract cs -> (
            let storage_type = Love_tenv.get_storage_type env in
            let ct = liqcontract_sig_to_lovetype ?storage_type env cs in
            mk_apply
              (mk_const @@ mk_cprimitive (PCSelf ct))
              [mk_const @@ mk_cunit ()],
            TContractInstance ct
          )
        | _ -> failwith "Self should have the type contract"
      )
    | Apply {prim; args} -> (
        debug "[liqexp_to_loveexp] Creating a Primitive application@.";
        liqapply_to_loveexp env e.ty prim args
      )
    | If {cond; ifthen; ifelse} ->
      debug "[liqexp_to_loveexp] Creating an ITE@.";
      let cond, _ = ltl cond in
      let ifthen, t = ltl ifthen in
      let ifelse, t' = ltl ifelse in
      let ifthen,ifelse,t = Compil_utils.choose_best_and_merge (ifthen,t) (ifelse,t') in
      mk_if cond ifthen ifelse, t
    | Seq (e1, e2) ->
      debug "[liqexp_to_loveexp] Creating a sequence@.";
      let first,_ = ltl e1 in
      let last, t = ltl e2 in
      Seq [first; last], t
    | Transfer {dest; amount} ->
      debug "[liqexp_to_loveexp] Creating a Transfer@.";
      mk_apply
        (mk_const @@ mk_cprimitive (PATransfer))
        [fst @@ ltl dest; fst @@ ltl amount], TOperation
    | Call {contract; amount; entry; arg} ->
      debug "[liqexp_to_loveexp] Creating a Call@.";
      let name =
        match entry with
          None -> "main"
        | Some name -> name in
      let ctrct, typ = ltl contract in
      let csig =
        match contract.ty with
          Tcontract c -> c
        | t ->
          debug "[liqexp_to_loveexp] Error : Contract has type %a, which is not a contract type."
            Type.pretty typ;
          failwith "Contract has a non contract type"
      in
      let entry =
        let entries = csig.entries_sig in
        match List.find_opt (fun {entry_name; _} -> String.equal entry_name name) entries with
          None -> failwith (Format.asprintf "Entry point %s not found" name)
        | Some e -> e in

      let ptype = liqtype_to_lovetype env entry.parameter in
      let rtype = TUnit in
      let cstype =
       TContractInstance (
           Anonymous {
               storage_type = None; (* none or any type *)
               entries = StringMap.singleton name (Forbid, ptype, rtype);
               values = StringMap.empty;
               structures = StringMap.empty;
               signatures = StringMap.empty;
               types = StringMap.empty;
               is_module = false }) in
      let prim_entry_type = cstype @=> TEntryPoint (ptype, rtype) in
      let entry_point =
        mk_apply
          (mk_primitive_lambda (PEntryPoint name) prim_entry_type)
          [ctrct]
      in
      let htype = (* Check love_primitive.ml *)
          TEntryPoint (ptype, TUnit) @=> TDun @=> ptype @=> TTuple [TOption TOperation; TBool] in
      mk_apply
        (mk_primitive_lambda
           PCCall
           (TEntryPoint (ptype, rtype) @=> TDun @=> ptype @=> htype @=> TOperation))
        [entry_point;
         fst @@ ltl amount;
         fst @@ ltl arg;
         mk_none ~typ:htype ()], TOperation

    | MatchOption {arg; ifnone; some_name; ifsome} -> (
        debug "[liqexp_to_loveexp] Creating a Option match@.";
        let arg, targ = ltl arg in
        let env =
          match targ with
            TForall _ (* => arg = None *) -> env
          | TOption opt ->
            Compil_utils.add_var
              some_name.nname
              opt
              env
          | _ ->
            debug
              "[liqexp_to_loveexp] Error : argument has type %a, this is not an option.@."
              Love_type.pretty targ;
            failwith "Matching on option with argument that is not an option" in
        let ifnone, t = liqexp_to_loveexp env ifnone in
        let ifsome, t' = liqexp_to_loveexp env ifsome in

        let ifnone, ifsome, t =
          Compil_utils.choose_best_and_merge (ifnone,t) (ifsome,t') in
        mk_match
          arg
          [mk_pnone (), ifnone; mk_psome (mk_pvar (some_name.nname)),ifsome], t
      )
    | MatchList { arg; head_name; tail_name; ifcons; ifnil} -> (
        debug "[liqexp_to_loveexp] Creating a List Match@.";
        let arg, targ = ltl arg in
        debug "[liqexp_to_loveexp] Argument %a : %a@."
          Typed.Exp.print arg
          Love_type.pretty targ;
        match targ with
        | TList elttyp ->
          let new_env =
               Compil_utils.add_var head_name.nname elttyp env
          in
          let new_env =
               Compil_utils.add_var tail_name.nname targ new_env in
          let ifnil, t = ltl ifnil in
          let ifcons, t' = liqexp_to_loveexp new_env ifcons in
          let ifnil,ifcons,t = Compil_utils.choose_best_and_merge (ifnil,t) (ifcons,t') in
          mk_match
            arg
            [mk_plist [], ifnil;
             mk_plist [
               mk_pvar head_name.nname;
               mk_pvar tail_name.nname],  ifcons
            ], t
        | _ -> failwith "List matching with argument that is not a list"
      )
    | Loop l ->
      debug "[liqexp_to_loveexp] Creating a Loop@.";
      let arg, arg_type = ltl l.arg in
      debug "[liqexp_to_loveexp] Loop argument = %a:%a@."
        Typed.Exp.print arg Love_type.pretty arg_type
      ;
      let env = Compil_utils.add_var l.arg_name.nname arg_type env in
      let body =
        mk_lambda (mk_pvar l.arg_name.nname) (fst @@ liqexp_to_loveexp env l.body) arg_type in
      (mk_apply
         (mk_primitive_lambda
            PLLoop
            ((arg_type @=> TTuple [TBool;arg_type]) @=> arg_type @=> arg_type)
         )
         [body; arg]),
      arg_type

    | LoopLeft _ -> failwith "TODO LoopLeft"
    | Fold {prim; arg_name; body; arg; acc} ->
      debug "[liqexp_to_loveexp] Creating a fold@.";
      (* In Liquidity, args of fold/iter are tuples. *) (*
    mk_apply
      (mk_const @@ mk_cprimitive @@ liqprimfold_to_loveprim prim)
      [ltl body; ltl arg; ltl acc] *)
      let arg, arg_typs = ltl arg in
      let acc, acc_typ = ltl acc in
      fst @@
      liqprimfold_to_loveexp
        env
        prim
        arg_name.nname
        arg
        arg_typs
        acc
        acc_typ
        liqexp_to_loveexp
        body, acc_typ

    | Map {prim; arg_name; body; arg} ->
      debug "[liqexp_to_loveexp] Creating a map@.";
      let arg, arg_type = ltl arg in
      liqprimmap_to_loveexp
        env
        prim
        arg_name.nname
        liqexp_to_loveexp
        body
        arg
        arg_type

    | MapFold {prim; arg_name; body; arg; acc} ->
      let arg, arg_typ = ltl arg in
      let acc, acc_typ = ltl acc in
      liqprimmapfold_to_loveexp
        env
        prim
        arg_name.nname
        liqexp_to_loveexp
        body
        arg
        arg_typ
        acc
        acc_typ
    | Lambda {arg_name; arg_ty; body; ret_ty; recursive = Some _} ->
      debug "[liqexp_to_loveexp] Creating a recursive lambda@.";
      failwith "Recursive lambda not supported."
    | Lambda {arg_name; arg_ty; body; recursive = None; _} -> (
        debug "[liqexp_to_loveexp] Creating a non recursive lambda@.";
        let arg_ty = liqtype_to_lovetype env arg_ty
        in
        let env = Compil_utils.add_var arg_name.nname arg_ty env in
        debug "[liqexp_to_loveexp] fun (%s : %a) -> ...@."
          arg_name.nname Love_type.pretty arg_ty;
        let new_fvars = (Love_type.fvars arg_ty)
        in
        let quant = Love_tenv.get_free env in
        let quant = TypeVarMap.fold (fun tv _ acc -> TypeVarSet.add tv acc) quant TypeVarSet.empty in
        if TypeVarSet.subset new_fvars quant
        then (
          debug "[liqexp_to_loveexp] Introducing no new free var@.";
          let body, t = liqexp_to_loveexp env body in
          mk_lambda
            (mk_pvar arg_name.nname)
            body
            arg_ty, arg_ty @=> t
        )
        else (
          debug "[liqexp_to_loveexp] Introducing new free vars@.";
          let new_body, t =
            liqexp_to_loveexp (
              TypeVarSet.fold
                (fun tv acc -> Love_tenv.add_forall tv TUnit acc)
                (* Type is not really TUnit, it is just to keep track that tv
                   is polymorphic as it belongs to the forall map of the environment. *)
                new_fvars
                env) body
          in
          TypeVarSet.fold
            (fun tv (tlam, ty) ->
               if TypeVarSet.mem tv quant
               then tlam, ty
               else (
                 debug "[liqexp_to_loveexp] Adding parameter %a@." Love_type.pp_typvar tv;
                 mk_tlambda tv tlam, TForall (tv, ty)
               )
            )
            new_fvars
            ((mk_lambda (mk_pvar arg_name.nname) new_body arg_ty), arg_ty @=> t)
        )
      )
    | Closure _ ->
      debug "[liqexp_to_loveexp] Creating a closure (expect failure)@.";
      failwith "Closures are forbidden in Love"
    | Record [] -> assert false
    | Record l -> (
        debug "[liqexp_to_loveexp] Creating a record@.";
        let ty = liqtype_to_lovetype env e.ty in
        mk_record (List.map (fun (f, exp) -> string_to_ident f, fst @@ ltl exp) l), ty
      )

    | Constructor {constr = Constr c; arg} -> (
        debug "[liqexp_to_loveexp] Creating a construction %s@." c;
        let id = string_to_ident c in
        let arg, ty = ltl arg in
        mk_constr id [arg], ty
      )

    | Constructor {constr; arg} ->
      debug "[liqexp_to_loveexp] Creating a Left@.";
      let arg, targ = ltl arg in
      let tor_typs t = match t with Tor (t1, t2) -> t1, t2 | _ -> failwith "Expected Tor" in
      let id, params =
        match constr with
          Left _ ->
          let t2 = snd @@ tor_typs e.ty in
          "Left", [targ; liqtype_to_lovetype env t2]
        | Right _ ->
          let t1 = fst @@ tor_typs e.ty in "Right", [liqtype_to_lovetype env t1; targ]
        | _ -> assert false in
      let ty = TUser (Compil_utils.Tor.tor_typename, params) in
      mk_constr (string_to_ident id) [arg], ty
    | MatchVariant {arg; cases} ->
      debug "[liqexp_to_loveexp] Creating a constructor match@.";
      let arg, _targ = ltl arg in
      let patterns, t =
        List.fold_left
          (fun (acc_p, acc_t) (pat, exp) ->
             let pat, env =
               match pat with
                 PConstr (name, []) ->
                 debug "[liqexp_to_loveexp] Empty constructor %s.@." name;
                 mk_pconstr
                   (string_to_ident name)
                   [mk_pany ()], env
               | PConstr (name, [arg]) ->
                 debug "[liqexp_to_loveexp] Simple constructor %s.@." name;
                 let n = string_to_ident name in
                 let arg_typ =
                   match Love_tenv.find_constr n env with
                     None -> failwith ("In match, unknown constructor " ^ name)
                   | Some {cargs=[t];_} -> t
                   | Some _ -> failwith (name ^ " Constructor : bad number of arguments")
                 in
                 mk_pconstr n [mk_pvar arg], (Compil_utils.add_var arg arg_typ env)
               | PConstr (name, args) ->
                 let n = string_to_ident name in
                 let arg_typs =
                   match Love_tenv.find_constr n env with
                     None -> failwith ("In match, unknown constructor " ^ name)
                   | Some {cargs=[TTuple l];_} -> l
                   | Some _ -> failwith (name ^ " Constructor : argument should be a tuple")
                 in
                 debug "[liqexp_to_loveexp] Constructor %s with %i arguments.@." name
                   (List.length args);
                 let new_env =
                   List.fold_left2
                     (fun env arg arg_typ -> Compil_utils.add_var arg arg_typ env)
                     env
                     args
                     arg_typs
                 in
                 mk_pconstr
                   n
                   [mk_ptuple (List.map (fun a -> mk_pvar a) args)], new_env
               | PAny -> mk_pany (), env
             in
             debug "[liqexp_to_loveexp] Building the expression case@.";
             let exp, t = liqexp_to_loveexp env exp in
             match acc_t, t with
               TVar _, _
             | TForall _, TForall _ -> (pat, exp) :: acc_p, t

             | TForall _, _ ->
               let new_acc_p =
                 List.map (fun (p, e) -> p, mk_tapply e t) acc_p in
               ((pat, exp) :: new_acc_p), t
             | _,_ -> (pat, exp) :: acc_p, t
          )
          ([], TVar (Love_type.fresh_typevar ()))
          cases
      in
      let m = mk_match arg (List.rev patterns)
      in m, t

    | MatchNat {arg; plus_name; ifplus; minus_name; ifminus} ->
      debug "[liqexp_to_loveexp] Creating a sign match@.";
      (* let ##tmp = arg in    // this line is important as arg may execute side effects
         if ##tmp >= 0
         then let 'plus_name' = ##tmp in ifplus
         else let 'minus_name' = ##tmp in ifminus
      *)
      let tmp_name = "##tmp" in
      let plusenv = Compil_utils.add_var plus_name.nname TInt env in
      let minenv = Compil_utils.add_var minus_name.nname TInt env in
      let ifplus, t = liqexp_to_loveexp plusenv ifplus in
      let ifminus, t' = liqexp_to_loveexp minenv ifminus in
      let ifplus, ifminus, t = Compil_utils.choose_best_and_merge (ifplus,t) (ifminus,t')
      in
      let tmp_varid = Love_ident.create_id tmp_name in
      mk_let (mk_pvar tmp_name) (fst @@ ltl arg) (
        mk_if
          (mk_apply (mk_const (mk_cprimitive PGe)) [mk_var tmp_varid; mk_const (mk_cint (Z.zero))])
          (mk_let
             (mk_pvar plus_name.nname)
             (mk_var tmp_varid)
             ifplus
          )
          (mk_let
             (mk_pvar minus_name.nname)
             (mk_var tmp_varid)
             ifminus
          )
      ), t

    | Failwith fail ->
      let fail', tfail = liqexp_to_loveexp env fail in
      debug "[liqexp_to_loveexp] Fail = %a@." Typed.Exp.print fail';
      let rettyp = liqtype_to_lovetype env e.ty in
      mk_tapply (
        mk_apply
          (mk_tapply (mk_const @@ mk_cprimitive PFailwith) tfail)
          [fail']
      ) rettyp
        , rettyp
    | CreateContract {args; contract} ->
      debug "[liqexp_to_loveexp] Creating a contract creation@.";
      let name_id = string_to_ident contract.contract_name in
      let ctr =
        match Love_tenv.find_contract name_id env with
          None ->
          let first_class_ctr =
            Typed.Structure.Anonymous (fst @@ liqcontract_to_lovecontract ~env false contract) in
          mk_packstruct first_class_ctr
        | Some _ -> mk_packstruct (Named name_id)
      in
      mk_apply
        (mk_const @@ mk_cprimitive PCCreate)
        (List.map (fun a -> fst @@ ltl a) args @ [ctr]),
      Love_type.return_type (Love_primitive.type_of PCCreate)

    | ContractAt {arg; c_sig} ->
      debug "[liqexp_to_loveexp] Creating a contract at@.";
      let ctr_typ = liqcontract_sig_to_lovetype env c_sig in
      mk_apply
        (mk_const @@ mk_cprimitive (PCAt ctr_typ))
        [fst @@ ltl arg], TOption (TContractInstance ctr_typ)

    | Unpack {arg; ty} ->
      debug "[liqexp_to_loveexp] Creating an unpack@.";
      let t = liqtype_to_lovetype env ty in
      mk_apply
        (mk_const @@ mk_cprimitive (PBUnpack t))
        [fst @@ ltl arg], TOption t

    | TypeAnnot {e; ty} ->
      debug "[liqexp_to_loveexp] Creating a type annoted expression (discarding type)@.";
      ltl e

    | Type _ ->
      failwith "Type expressions forbidden in love"
  in
  debug "[liqexp_to_loveexp] Expression %a : %a@." Typed.Exp.print exp Love_type.pretty t;
  let expected_typ =
    match e.ty with
      Tfail -> debug "[liqexp_to_loveexp] Failure type, treated differently@."; t
    | Tpartial _ -> debug "[liqexp_to_loveexp] Partial type, not treated@."; t
    | _ -> liqtype_to_lovetype env e.ty
  in
  debug
    "[liqexp_to_loveexp] Expected type for expression %a is %a \n: Matching type %a with expected type %a@."
    Typed.Exp.print exp Love_type.pretty expected_typ
    Love_type.pretty t Love_type.pretty expected_typ;
  let e, t = Compil_utils.apply_types exp t expected_typ in
  debug "[liqexp_to_loveexp] New expression %a : %a@." Typed.Exp.print e Love_type.pretty t;
  let fvars = Love_type.fvars t in
  let t,e =
    TypeVarSet.fold
      (fun tv (acc_t, acc_e) ->
         TForall (tv, acc_t),
         Typed.Exp.TLambda {targ = tv;exp = acc_e}
      )
      fvars
      (t,e) in
  debug "[liqexp_to_loveexp] Forall type %a : %a@." Typed.Exp.print e Love_type.pretty t;
  e, t

and liqvalue_to_lovecontent env {val_name; inline; val_private; val_exp} :
  (string * Typed.Structure.content) * env =
  debug "[liqvalue_to_lovecontent] Creating value %s@." val_name;
  let code, typ = liqexp_to_loveexp env val_exp in
  let visibility = (if val_private then Private else Public) in
  let purity = View in
  debug "[liqvalue_to_lovecontent] Value %s = %a:%a@."
    val_name
    Typed.Exp.print code
    Love_type.pretty typ;
  (val_name, mk_value code typ purity visibility),
  Compil_utils.add_var ~kind:(Value (visibility, purity)) val_name typ env


and liqentry_to_lovecontent env {entry_sig; code} =
  let param_type = liqtype_to_lovetype env entry_sig.parameter in
  let stor_typ =
    stor_typ_from_opt_typ @@ Love_tenv.get_storage_type env in
  let env = Compil_utils.add_var entry_sig.parameter_name param_type env in
  let env = Compil_utils.add_var entry_sig.storage_name stor_typ env in
  let full_love_code =
    let lovecode, _ = liqexp_to_loveexp env code in
    let res_op = "##LOVERESULT_operations" in
    let res_st = "##LOVERESULT_storage" in
    debug "[liqentry_to_lovecontent] (oper, stor) = %a @." Typed.Exp.print lovecode;
    mk_let
      (mk_ptuple [mk_pvar res_op; mk_pvar res_st])
      lovecode
      (mk_tuple [
          mk_const @@ mk_cunit ();
          mk_var (Love_ident.create_id res_op);
          mk_var (Love_ident.create_id res_st)]) in
  let () =
    debug "[liqentry_to_lovecontent] \
           Creating entry point with storage type = %a and parameter type = %a@."
      Love_type.pretty stor_typ
      Love_type.pretty param_type in
  let code =
    mk_entry_point_lambda
      entry_sig.storage_name
      stor_typ
      entry_sig.parameter_name
      param_type
      full_love_code in
  let visibility = Public in
  let reentrant = Allow in
  (entry_sig.entry_name, mk_entry code param_type TUnit visibility reentrant),
  Compil_utils.add_var
    ~kind:(Entry (visibility, reentrant))
    entry_sig.entry_name
    (TEntryPoint (param_type, TUnit)) env

and liqcontract_to_lovecontent
    env (c : typed_contract) : string * Typed.Structure.content * env =
<<<<<<< HEAD
  debug "[liqcontract_to_lovecontent] Sub contract %s@." c.contract_name;
  let ctr, subenv =
    liqcontract_to_lovecontract ~env:(env_of_subcontract (LiquidTypes.is_only_module c) env) c in
  debug "[liqcontract_to_lovecontent] Signature of subcontract : %a@."
=======
  debug "[liqcontract_to_lovecontent] Sub structure %s@." c.contract_name;
  let is_module = LiquidTypes.is_only_module c in
  debug "[liqcontract_to_lovecontent] Structure %s is a %s@."
    c.contract_name
    (if is_module then "module" else "contract") ;
  let ctr, subenv =
    liqcontract_to_lovecontract ~env:(env_of_subcontract is_module env) is_module c in
  debug "[liqcontract_to_lovecontent] Signature of sub structure : %a@."
>>>>>>> next
    Love_tenv.pp_env subenv;
  let new_env =
    Love_tenv.add_subcontract_env
      c.contract_name
      subenv
      env in
  debug "[liqcontract_to_lovecontent] New environment: %a@."
    Love_tenv.pp_env new_env;
  c.contract_name, mk_structure ctr, new_env

and liqcontract_to_lovecontract
<<<<<<< HEAD
    ?env ?(ctr_name="") (c : typed_contract) : Typed.Structure.t * env =
  debug "[liqcontract_to_lovecontract] Transpiling liquidity contract@.";
  let env =
    match env with
      None -> empty_env (LiquidTypes.is_only_module c) ()
=======
    ?env ?(ctr_name="") (is_module : bool) (c : typed_contract) : Typed.Structure.t * env =
  debug "[liqcontract_to_lovecontract] Transpiling liquidity contract@.";
  let env =
    match env with
      None -> empty_env is_module ()
>>>>>>> next
    | Some e -> e in
  let env = (*  Adding type definitions *)
    let rec fill_env_with_types
        (types : (datatype list -> datatype) StringMap.t) (str : string) typ acc =
      let res =
        let data = Love_tenv.get_data acc in
        if
          List.exists (fun (n, _) -> String.equal n str) data.typedefs
        then acc
        else (
          debug "[liqcontract_to_lovecontract] Adding type %s to environment@." str;
          try
            let t = liqtype_to_lovetypedef acc (typ []) in
            match t with
              Some tdef ->
              debug "[liqcontract_to_lovecontract] %a@." pp_typdef tdef;
              add_typedef_to_contract tdef acc
            | None ->
              debug "[liqcontract_to_lovecontract] Type has no definition@.";
              acc
          with
            UnknownType (s,_, _) ->
            debug "[liqcontract_to_lovecontract] %s is not in the environment@." s;
            try
              let acc = fill_env_with_types types s (StringMap.find s types) acc
              in
              fill_env_with_types types str typ acc
            with
              UnknownType (s', _, _) when String.equal s' str ->
              failwith "Forbidden inter recursive types"
        )
      in
      debug "[liqcontract_to_lovecontract] Type %s added@." str;
      res
    in
    StringMap.fold
      (fill_env_with_types c.ty_env.types)
      c.ty_env.types
      env
  in
  let env, signatures =
    StringMap.fold (
      fun name cs (env, sigs) ->
        let name = name^"#signature" in
        debug "[liqcontract_to_lovecontract] Registering signature %s@." name;
        let storage_type =
          if String.equal name ctr_name
          then Love_tenv.get_storage_type env
          else None
        in
        match liqcontract_sig_to_lovetype ?storage_type env cs with
          Anonymous s ->
          debug "[liqcontract_to_lovecontract] Signature %s = %a@." name Type.pp_contract_sig s;
          Love_tenv.add_signature name (Love_tenv.contract_sig_to_env {typedefs = []} s) env,
          (name,(Typed.Structure.Signature s)) :: sigs
        | Named _ -> failwith "TODO : add named signatures to signature definition"
    )
      c.ty_env.contract_types
      (env, []) in
  let types =
    List.map
      (fun (n, t) -> n, Love_ast_utils.mk_type t)
      (List.rev (Love_tenv.get_data env).typedefs) in
  debug "[liqcontract_to_lovecontract] %i subcontracts/modules to handle@." (List.length c.subs);
  let subc, env =
    List.fold_left
      (fun (acc_subc, acc_env) c ->
         let n, sc, new_env = liqcontract_to_lovecontent acc_env c in
         (n, sc) :: acc_subc, new_env
      )
      ([], env)
      c.subs
  in
  let storage_type = liqtype_to_lovetype env c.storage
  in
  debug "[liqcontract_to_lovecontract] Storage type = %a@." Type.pretty storage_type;
  let env = Love_tenv.set_storage_type storage_type env in
  let subc = List.rev subc in
  let values, env =
    List.fold_left
      (fun (acc_v, env) v ->
         let v', env = liqvalue_to_lovecontent env v in
         v' :: acc_v, env)
      ([], env)
      c.values in
  let values = List.rev values in
  let entries, env =
    List.fold_left
      (fun (acc_v, env) v ->
         let v', env = liqentry_to_lovecontent env v in
         v' :: acc_v, env)
      ([], env)
      c.entries in
  let entries = List.rev entries in
  let str =
    if is_module
    then mk_module_struct (types @ signatures @ values @ subc @ entries)
    else
      mk_contract_struct
        ~storage_type
        (types @ signatures @ values @ subc @ entries) in
  str, env

let initial_env =
  let empty = empty_env false () in
  add_typedef_to_contract Compil_utils.Tor.tor_typedef empty


let liqcontract_to_lovecontract ~(ctr_name:string) (c : typed_contract) : Typed.Structure.t * env =
  debug "[liqcontract_to_lovecontract] Registering contract %s@." ctr_name;
  try
    let love_contract, env = liqcontract_to_lovecontract ~ctr_name ~env:initial_env false c in
    (* Adding missing type def *)
    {love_contract with
     content =
       (Compil_utils.Tor.tor_typename.tname, Typed.Structure.Type Compil_utils.Tor.tor_typedef)
       :: love_contract.content
    }, env
  with
    (UnknownType (_,_,e)) as exc ->
    debug "Failing with typing environment =\n%a@."
      Love_tenv.pp_env e;
    raise exc
